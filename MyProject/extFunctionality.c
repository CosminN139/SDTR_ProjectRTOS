/*
 * extFunctionality.c
 *
 * Created: 10/20/20
 *  Author: Cosmin Nastase
 */ 

//compiler-defined includes
#include <avr/interrupt.h>

//aditional system-defined includes
#include "FreeRTOS.h"
#include "task.h"
#include "portmacro.h"

//user-defined includes
#include "myTasks.h"
#include "testLED.h"
#include "extFunctionality.h"

//global variables,magic numbers etc.

//////////////////////////////////////////////////////////////////////////

/*
let's handle an external interrupt 
*/



ISR(INT7_vect)
{	
	xTaskResumeFromISR(myTaskHandle);
	vPortYieldFromTick();
  	
}

//////////////////////////////////////////////////////////////////////////
/*
Before using any type of interrupts we need to initialise that, so the system knows about that usage
*Any interrupt can be generated internally , using a dedicated timer
*or externally , using a signal which triggers a dedicated pin for an interrupt

*So that FreeRTOS does support user triggered interrupts, but is not recommended that the system to be halted
*because of that usage very much because it can crash the os
*/

void ext_int_init	(	void	)
//////////////////////////////////////////////////////////////////////////
/*
Usage:
*So for this case we gonna be using an external interrupt , that is generated by a button
*For this usage we need to declare an input pin which will also use as interrupt trigger pin
*We'll use INT7 pin (PIN E7) , which is also an sychronous trigger pin.
*What does this mean? Every interrupt will be generated only on falling/rising edge of clock signal 
*/
{	
	DDR_INText	&=	~(	1 << BIT_INText		);	//Set a pin correspondig to an interrupt as an input
	PORT_INText	|=	 (	1 << BIT_INText		);	//Defining a pull-up to prevent input floating
	
	EICRB		|=	 (	1 << ISC70			);	//Any logical change on INT7 generates an interrupt req
	EIMSK		|=	 (	1 << INT7			);	//Puts the status register(sREG) for that interrupt in 1, so the interrupt is enabled
}