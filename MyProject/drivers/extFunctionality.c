/*
 * extFunctionality.c
 *
 * Created: 10/20/20
 *  Author: Cosmin Nastase
 */ 

//compiler-defined includes
#include <avr/interrupt.h>
#include <inttypes.h>

//aditional system-defined includes
#include "FreeRTOS.h"
#include "task.h"
#include "portmacro.h"
#include "semphr.h"

//user-defined includes
#include "../myTasks.h"
#include "../demos/testLED.h"
#include "../drivers/LCD_Driver.h"
#include "../drivers/extFunctionality.h"
#include "../drivers/DHT.h"
#include "../drivers/UART_Driver.h"
//global variables,magic numbers etc.

//////////////////////////////////////////////////////////////////////////

/*
let's handle an external interrupt 

*As for a classic embedded software , for handling an interrupt we need an ISR(interrupt service routine) that is trigered
*using a flag. That flag could be obtained using a timer ,which can be an overflow flag or a compare flag , or external by 
*triggering a designated pin
*/

ISR(INT7_vect)
{	
	
	xTaskResumeFromISR	(	myTaskHandle	);
	//vPortYieldFromTick();
  	
}

//////////////////////////////////////////////////////////////////////////
/*
Before using any type of interrupts we need to initialise that, so the system knows about that usage
*Any interrupt can be generated internally , using a dedicated timer
*or externally , using a signal which triggers a dedicated pin for an interrupt

*So that FreeRTOS does support user triggered interrupts, but is not recommended that the system to be halted
*because of that usage very much because it can crash the os
*/

void ext_int_init	(	void	)
//////////////////////////////////////////////////////////////////////////
/*
Usage:
*So for this case we gonna be using an external interrupt , that is generated by a button
*For this usage we need to declare an input pin which will also use as interrupt trigger pin
*We'll use INT7 pin (PIN E7) , which is also an sychronous trigger pin.
*What does this mean? Every interrupt will be generated only on falling/rising edge of clock signal 
*/
{	
	DDR_INText	&=	~(	1 << BIT_INText		);	//Set a pin corresponding to an interrupt as an input
	PORT_INText	|=	 (	1 << BIT_INText		);	//Defining a pull-up to prevent input floating
	
	EICRB		|=	 (	1 << ISC70			);	//Any logical change on INT7 generates an interrupt req
	EIMSK		|=	 (	1 << INT7			);	//Puts the status register(sREG) for that interrupt in 1, so the interrupt is enabled
}

void vButtonInit(void)
{
	// Set SWITCH_IP as input pin
	DDR_SWITCH_IP &= ~(1<<BIT_SWITCH_IP);
	// Enable pull-up on SWITCH_IP
	PORT_SWITCH_IP |= (1<<BIT_SWITCH_IP);
}

void vButtonSerialInit(void)
{
	// Set SWITCH_IP as input pin
	DDR_SWITCHSERIAL_IP &= ~(1<<BIT_SWITCHSERIAL_IP);
	// Enable pull-up on SWITCH_IP
	PORT_SWITCHSERIAL_IP |= (1<<BIT_SWITCHSERIAL_IP);
}

char xButtonGetStatus(void)
{
	// See if switch is pressed
	if((PIN_SWITCH_IP&(1<<BIT_SWITCH_IP)) == 0)
	{
		return pdTRUE;
	}
	else
	{
		return pdFALSE;
	}
}

char xSensorGetStatus(void)

{	
	//See if sensor got any data to send
	if (dht_GetTempUtil(NULL , NULL) != -1)
	{
		return pdTRUE;
	}
	else
	{
		return pdFALSE;
	}	
}

char xSerialGetStatus(void)
{
	//Check if we have some messages to deal with on serial rx
	 
	
	//See if the magic button on board is pressed
	if ((PIN_SWITCHSERIAL_IP&(1<<BIT_SWITCHSERIAL_IP)) == 0)
	{
		return pdFALSE;
	}
	//no magic moment occures right now
	else
	{
		return pdFALSE;
	}
}